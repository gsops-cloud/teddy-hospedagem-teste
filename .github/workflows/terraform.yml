name: Terraform Infrastructure

on:
  workflow_dispatch:
    inputs:
      action:
        description: 'AÃ§Ã£o a ser executada'
        required: true
        type: choice
        options:
          - apply
          - destroy

jobs:
  terraform:
    name: Terraform ${{ github.event.inputs.action }}
    runs-on: ubuntu-latest
    environment: production
    
    steps:
      - name: Checkout cÃ³digo
        uses: actions/checkout@v4

      - name: Configurar AWS CLI
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION || 'us-east-1' }}

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.6.0

      - name: Validar secrets obrigatÃ³rios
        run: |
          if [ -z "${{ secrets.S3_BUCKET_NAME }}" ]; then
            echo "âŒ Erro: S3_BUCKET_NAME nÃ£o estÃ¡ configurado nos secrets do GitHub!"
            echo "ðŸ’¡ Configure o secret S3_BUCKET_NAME em Settings > Secrets and variables > Actions"
            exit 1
          fi
          echo "âœ… Secrets validados"

      - name: Criar arquivo terraform.tfvars
        working-directory: ./terraform
        run: |
          cat > terraform.tfvars <<EOF
          aws_region  = "${{ secrets.AWS_REGION || 'us-east-1' }}"
          bucket_name = "${{ secrets.S3_BUCKET_NAME }}"
          environment = "${{ secrets.TERRAFORM_ENVIRONMENT || 'prod' }}"
          EOF
          echo "âœ… Arquivo terraform.tfvars criado"
          echo "ðŸ“¦ Bucket: ${{ secrets.S3_BUCKET_NAME }}"
          echo "ðŸŒ RegiÃ£o: ${{ secrets.AWS_REGION || 'us-east-1' }}"
          echo "ðŸ”§ Ambiente: ${{ secrets.TERRAFORM_ENVIRONMENT || 'prod' }}"

      - name: Preparar bucket de state do Terraform
        run: |
          STATE_BUCKET="${{ secrets.S3_BUCKET_NAME }}-terraform-state"
          REGION="${{ secrets.AWS_REGION || 'us-east-1' }}"
          
          echo "ðŸ” Verificando bucket de state: $STATE_BUCKET"
          
          if aws s3api head-bucket --bucket "$STATE_BUCKET" 2>/dev/null; then
            echo "âœ… Bucket de state jÃ¡ existe: $STATE_BUCKET"
          else
            echo "ðŸ“¦ Criando bucket de state: $STATE_BUCKET na regiÃ£o $REGION"
            
            if [ "$REGION" = "us-east-1" ]; then
              aws s3api create-bucket \
                --bucket "$STATE_BUCKET" \
                --region "$REGION" || {
                  echo "âš ï¸ Erro ao criar bucket. Pode jÃ¡ existir em outra regiÃ£o ou ter problema de permissÃµes."
                  exit 1
                }
            else
              aws s3api create-bucket \
                --bucket "$STATE_BUCKET" \
                --region "$REGION" \
                --create-bucket-configuration LocationConstraint="$REGION" || {
                  echo "âš ï¸ Erro ao criar bucket. Pode jÃ¡ existir em outra regiÃ£o ou ter problema de permissÃµes."
                  exit 1
                }
            fi
            
            sleep 3
            
            aws s3api put-bucket-versioning \
              --bucket "$STATE_BUCKET" \
              --versioning-configuration Status=Enabled
            
            aws s3api put-public-access-block \
              --bucket "$STATE_BUCKET" \
              --public-access-block-configuration \
              "BlockPublicAcls=true,IgnorePublicAcls=true,BlockPublicPolicy=true,RestrictPublicBuckets=true"
            
            aws s3api put-bucket-encryption \
              --bucket "$STATE_BUCKET" \
              --server-side-encryption-configuration '{
                "Rules": [{
                  "ApplyServerSideEncryptionByDefault": {
                    "SSEAlgorithm": "AES256"
                  }
                }]
              }' 2>/dev/null || echo "âš ï¸ NÃ£o foi possÃ­vel configurar criptografia (pode nÃ£o ter permissÃ£o)"
            
            echo "âœ… Bucket de state criado e configurado: $STATE_BUCKET"
          fi
          
          echo "STATE_BUCKET=$STATE_BUCKET" >> $GITHUB_ENV
          echo "AWS_REGION=$REGION" >> $GITHUB_ENV
          echo "ðŸ“‹ Bucket de state: $STATE_BUCKET"

      - name: Terraform Init
        working-directory: ./terraform
        run: |
          terraform init \
            -backend-config="bucket=${{ env.STATE_BUCKET }}" \
            -backend-config="key=terraform.tfstate" \
            -backend-config="region=${{ env.AWS_REGION }}" \
            -backend-config="encrypt=true"

      - name: Terraform Validate
        working-directory: ./terraform
        run: terraform validate

      - name: Importar recursos existentes (para apply)
        if: github.event.inputs.action == 'apply'
        working-directory: ./terraform
        continue-on-error: true
        run: |
          BUCKET_NAME="${{ secrets.S3_BUCKET_NAME }}"
          REGION="${{ secrets.AWS_REGION || 'us-east-1' }}"
          
          echo "ðŸ” Verificando se hÃ¡ recursos existentes na AWS que precisam ser importados..."
          
          if aws s3api head-bucket --bucket "$BUCKET_NAME" 2>/dev/null; then
            echo "âœ… Bucket '$BUCKET_NAME' existe na AWS"
            
            if terraform state show aws_s3_bucket.website 2>/dev/null | grep -q "bucket.*=.*\"$BUCKET_NAME\""; then
              echo "âœ… Bucket jÃ¡ estÃ¡ no state do Terraform"
            else
              echo "ðŸ“¥ Importando bucket para o state do Terraform..."
              terraform import aws_s3_bucket.website "$BUCKET_NAME" || {
                echo "âš ï¸ NÃ£o foi possÃ­vel importar o bucket automaticamente."
                echo "ðŸ’¡ Isso pode acontecer se o bucket foi criado fora do Terraform."
                echo "   O Terraform tentarÃ¡ atualizar o state durante o plan/apply."
                exit 0
              }
              
              echo "ðŸ“¥ Tentando importar recursos relacionados do bucket..."
              
              terraform import aws_s3_bucket_public_access_block.website "$BUCKET_NAME" 2>/dev/null && echo "  âœ… Public access block importado" || echo "  âš ï¸ Public access block nÃ£o encontrado"
              
              terraform import aws_s3_bucket_versioning.website "$BUCKET_NAME" 2>/dev/null && echo "  âœ… Versioning importado" || echo "  âš ï¸ Versioning nÃ£o encontrado"
              
              echo "ðŸ” Buscando OAI existente..."
              OAI_LIST=$(aws cloudfront list-cloud-front-origin-access-identities --query "CloudFrontOriginAccessIdentityList.Items[*].[Id,Comment]" --output text 2>/dev/null || echo "")
              if [ -n "$OAI_LIST" ]; then
                OAI_ID=$(echo "$OAI_LIST" | grep "OAI for $BUCKET_NAME" | head -n 1 | awk '{print $1}' || echo "")
                if [ -n "$OAI_ID" ] && [ "$OAI_ID" != "None" ]; then
                  echo "ðŸ“¥ Importando OAI existente: $OAI_ID"
                  terraform import aws_cloudfront_origin_access_identity.website "$OAI_ID" 2>/dev/null && echo "  âœ… OAI importado" || echo "  âš ï¸ OAI nÃ£o pÃ´de ser importado"
                fi
              fi
              
              echo "ðŸ” Buscando CloudFront Distribution existente..."
              BUCKET_DOMAIN="$BUCKET_NAME.s3.$REGION.amazonaws.com"
              DIST_LIST=$(aws cloudfront list-distributions --query "DistributionList.Items[*].[Id,Origins.Items[0].DomainName]" --output text 2>/dev/null || echo "")
              if [ -n "$DIST_LIST" ]; then
                DIST_ID=$(echo "$DIST_LIST" | grep "$BUCKET_DOMAIN\|$BUCKET_NAME" | head -n 1 | awk '{print $1}' || echo "")
                if [ -n "$DIST_ID" ] && [ "$DIST_ID" != "None" ]; then
                  echo "ðŸ“¥ Importando CloudFront Distribution existente: $DIST_ID"
                  terraform import aws_cloudfront_distribution.website "$DIST_ID" 2>/dev/null && echo "  âœ… CloudFront Distribution importado" || echo "  âš ï¸ CloudFront Distribution nÃ£o pÃ´de ser importado"
                fi
              fi
              
              echo "âœ… Processo de importaÃ§Ã£o concluÃ­do"
            fi
          else
            echo "â„¹ï¸ Bucket nÃ£o existe ainda. SerÃ¡ criado pelo Terraform."
          fi

      - name: Verificar state e recursos existentes (para destroy)
        if: github.event.inputs.action == 'destroy'
        working-directory: ./terraform
        run: |
          echo "ðŸ” Verificando state no S3..."
          
          STATE_COUNT=$(terraform state list 2>/dev/null | wc -l || echo "0")
          
          if [ "$STATE_COUNT" -gt 0 ]; then
            echo "âœ… State encontrado com $STATE_COUNT recursos:"
            terraform state list
            echo "STATE_EXISTS=true" >> $GITHUB_ENV
          else
            echo "âš ï¸ Nenhum state encontrado no S3!"
            echo ""
            echo "ðŸ” Verificando se os recursos existem na AWS..."
            
            BUCKET_NAME="${{ secrets.S3_BUCKET_NAME }}"
            if aws s3api head-bucket --bucket "$BUCKET_NAME" 2>/dev/null; then
              echo "âš ï¸ O bucket '$BUCKET_NAME' existe na AWS, mas nÃ£o estÃ¡ no state!"
              echo ""
              echo "ðŸ“ SITUAÃ‡ÃƒO:"
              echo "   Os recursos foram criados antes de configurar o backend S3."
              echo "   O state local foi perdido e nÃ£o foi migrado para o S3."
              echo ""
              echo "ðŸ’¡ SOLUÃ‡Ã•ES:"
              echo "   1. Execute 'Terraform Apply' - ele detectarÃ¡ que os recursos jÃ¡ existem"
              echo "      e atualizarÃ¡ o state sem recriar nada (refresh)."
              echo "   2. Depois execute 'Terraform Destroy' para destruir os recursos."
              echo ""
              echo "   OU"
              echo ""
              echo "   1. Delete os recursos manualmente na AWS Console"
              echo "   2. Execute 'Terraform Apply' para criar tudo novamente com state no S3"
              echo ""
              echo "STATE_EXISTS=false" >> $GITHUB_ENV
            else
              echo "âœ… Nenhum recurso encontrado na AWS."
              echo "   NÃ£o hÃ¡ nada para destruir."
              echo "STATE_EXISTS=false" >> $GITHUB_ENV
            fi
          fi

      - name: Verificar se import foi necessÃ¡rio
        if: github.event.inputs.action == 'apply'
        working-directory: ./terraform
        run: |
          BUCKET_NAME="${{ secrets.S3_BUCKET_NAME }}"
          echo "ðŸ” Verificando se o bucket estÃ¡ no state apÃ³s importaÃ§Ã£o..."
          
          if terraform state show aws_s3_bucket.website 2>/dev/null | grep -q "bucket.*=.*\"$BUCKET_NAME\""; then
            echo "âœ… Bucket estÃ¡ no state. Pronto para plan/apply."
            echo "IMPORT_SUCCESS=true" >> $GITHUB_ENV
          else
            if aws s3api head-bucket --bucket "$BUCKET_NAME" 2>/dev/null; then
              echo "âš ï¸ Bucket existe na AWS mas nÃ£o estÃ¡ no state!"
              echo "ðŸ’¡ Tentando importar novamente..."
              terraform import aws_s3_bucket.website "$BUCKET_NAME" && echo "IMPORT_SUCCESS=true" >> $GITHUB_ENV || echo "IMPORT_SUCCESS=false" >> $GITHUB_ENV
            else
              echo "â„¹ï¸ Bucket nÃ£o existe. SerÃ¡ criado."
              echo "IMPORT_SUCCESS=true" >> $GITHUB_ENV
            fi
          fi

      - name: Terraform Plan
        if: github.event.inputs.action == 'apply' && env.IMPORT_SUCCESS == 'true'
        working-directory: ./terraform
        run: terraform plan -out=tfplan

      - name: Aviso - Import necessÃ¡rio
        if: github.event.inputs.action == 'apply' && env.IMPORT_SUCCESS == 'false'
        run: |
          echo "âŒ NÃ£o foi possÃ­vel importar o bucket automaticamente."
          echo ""
          echo "ðŸ’¡ SOLUÃ‡ÃƒO MANUAL:"
          echo "   1. Execute este comando localmente ou em um runner:"
          echo "      cd terraform"
          echo "      terraform init -backend-config=\"bucket=${{ secrets.S3_BUCKET_NAME }}-terraform-state\" -backend-config=\"key=terraform.tfstate\" -backend-config=\"region=${{ secrets.AWS_REGION || 'us-east-1' }}\" -backend-config=\"encrypt=true\""
          echo "      terraform import aws_s3_bucket.website ${{ secrets.S3_BUCKET_NAME }}"
          echo "   2. Depois execute o workflow novamente"
          echo ""
          exit 1

      - name: Terraform Apply
        if: github.event.inputs.action == 'apply' && env.IMPORT_SUCCESS == 'true'
        working-directory: ./terraform
        run: terraform apply -auto-approve tfplan

      - name: Verificar state apÃ³s apply
        if: github.event.inputs.action == 'apply'
        working-directory: ./terraform
        run: |
          echo "âœ… Apply concluÃ­do!"
          echo ""
          echo "ðŸ“‹ Recursos gerenciados pelo Terraform:"
          terraform state list
          echo ""
          echo "ðŸ’¾ State salvo no S3: s3://${{ env.STATE_BUCKET }}/terraform.tfstate"
          echo "   Agora vocÃª pode executar 'Terraform Destroy' e ele funcionarÃ¡ corretamente!"

      - name: Limpar bucket S3 antes do destroy
        if: github.event.inputs.action == 'destroy' && env.STATE_EXISTS == 'true'
        continue-on-error: true
        run: |
          BUCKET_NAME="${{ secrets.S3_BUCKET_NAME }}"
          
          echo "ðŸ§¹ Limpando bucket S3 antes do destroy..."
          
          if aws s3api head-bucket --bucket "$BUCKET_NAME" 2>/dev/null; then
            echo "ðŸ“¦ Limpando bucket: $BUCKET_NAME"
            
            cat > /tmp/empty_bucket.py << 'EOF'
          import boto3
          import sys
          
          bucket_name = sys.argv[1]
          s3 = boto3.client('s3')
          
          try:
              paginator = s3.get_paginator('list_object_versions')
              total = 0
              
              for page in paginator.paginate(Bucket=bucket_name):
                  delete_list = []
                  
                  if 'Versions' in page:
                      delete_list.extend([{'Key': v['Key'], 'VersionId': v['VersionId']} for v in page['Versions']])
                  if 'DeleteMarkers' in page:
                      delete_list.extend([{'Key': m['Key'], 'VersionId': m['VersionId']} for m in page['DeleteMarkers']])
                  
                  if delete_list:
                      for i in range(0, len(delete_list), 1000):
                          s3.delete_objects(Bucket=bucket_name, Delete={'Objects': delete_list[i:i+1000], 'Quiet': True})
                      total += len(delete_list)
              
              if total > 0:
                  print(f"âœ… Deletadas {total} versÃµes/markers")
              else:
                  print("â„¹ï¸ Nenhuma versÃ£o encontrada")
          except Exception as e:
              print(f"âš ï¸ {e}")
          EOF
            
            python3 /tmp/empty_bucket.py "$BUCKET_NAME" || {
              echo "âš ï¸ Python nÃ£o disponÃ­vel ou falhou, usando AWS CLI..."
              aws s3 rm s3://"$BUCKET_NAME"/ --recursive --quiet 2>/dev/null || true
            }
            
            echo "âœ… Limpeza concluÃ­da. O Terraform deletarÃ¡ o bucket (force_destroy=true)"
          else
            echo "â„¹ï¸ Bucket nÃ£o existe"
          fi

      - name: Terraform Destroy
        if: github.event.inputs.action == 'destroy' && env.STATE_EXISTS == 'true'
        working-directory: ./terraform
        run: terraform destroy -auto-approve

      - name: Aviso - Destroy nÃ£o executado
        if: github.event.inputs.action == 'destroy' && env.STATE_EXISTS == 'false'
        run: |
          echo "âŒ Destroy nÃ£o foi executado porque nÃ£o hÃ¡ state no S3."
          echo "ðŸ’¡ Execute primeiro 'Terraform Apply' para criar os recursos e salvar o state."
          exit 1

      - name: Output CloudFront URL
        if: github.event.inputs.action == 'apply'
        working-directory: ./terraform
        run: |
          echo "CloudFront URL: $(terraform output -raw cloudfront_url)"
          echo "CLOUDFRONT_URL=$(terraform output -raw cloudfront_url)" >> $GITHUB_ENV